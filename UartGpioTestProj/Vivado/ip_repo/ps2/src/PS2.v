`timescale 1ns / 1ps

/// \brief PS2 Peripheral for the VeSPA SoC
/// \input i_Clk Source Clock signal for the slave device, logic is processed on rising edges of this signal
/// \input i_Rst Reset signal for the device, active high
/// \input i_WEnable Write Enable signal. If this signal is set to high during a rising edge of the clock,
/// data is writen to the slave register file
/// \input i_WAddr Address of the register file that data should be writen to. This is a virtual address,
/// that should be generated by a Bus Interconnect device
/// \input i_WData Data writen to the slave register file if all the required conditions are complied
/// \input i_REnable Read Enable signal. If this signal is set to high during a rising edge of the clock,
/// data is read from the slave register file
/// \input i_RAddr Address of the register file that data will be read from. Simmilar to the i_WAddr, this
/// address should be generated by a Bus Interconnect device
/// \output o_RData When a read operation occurs, data is put on this output
/// \output o_Err This signal indicated an internal error occured on the device, such as an invalid address
/// \input i_Ps2Clk Incoming clock signal from the PS2 Keyboard
/// \input i_Ps2Sda Incoming data signal from the PS2 Keyaboard
module PS2
(
    //Bus related signals
    input i_Clk,
    input i_Rst,
    input i_WEnable,
    input [31:0] i_WAddr,
    input [31:0] i_WData,
    input i_REnable,
    input [31:0] i_RAddr,
    output reg [31:0] o_RData,
    output reg o_Err,
    //User signals begin here
    input i_Ps2Clk,
    input i_Ps2Sda,
    output [3:0] o_Data
);

parameter ST_IDLE   = 2'b00;
parameter ST_DATA   = 2'b01;
parameter ST_PARITY = 2'b10;
parameter ST_STOP   = 2'b11;

reg r_Ps2En, r_LastPulse, r_Temp, r_WritePending, r_UpdatePending, r_DataRdy;
reg [1:0] r_CurrentState;
reg [2:0] r_DataIndex;
reg [7:0] r_ShiftReg, r_DataOut;

wire w_Valid;
wire w_FifoEmpty;
wire [7:0] w_DataOut;

assign o_Data = w_DataOut;

Ps2Fifo _Ps2Fifo
(
    .rst(i_Rst),
    .clk(i_Clk),
    .din(r_ShiftReg),
    .wr_en(r_WritePending),
    .empty(w_FifoEmpty),
    .rd_en(!w_FifoEmpty && r_UpdatePending),
    .dout(w_DataOut),
    .valid(w_Valid)
);

always @(posedge i_Clk) begin
    if (i_Rst) begin
        o_Err <= 0;
        r_Ps2En <= 0;
        r_DataRdy <= 1;
        r_DataOut <= 0;
        r_ShiftReg <= 0;
        r_DataIndex <= 0;
        r_WritePending <= 0;
        r_CurrentState <= 0;
        r_UpdatePending <= 1;
    end
    else begin
        //Check if there is a write request pending
        if (i_WEnable) begin
            case (i_WAddr)
                2'b00: begin
                    r_Ps2En <= i_WData[0];
                end
                default: o_Err <= 1;
            endcase
        end
        //Check if there is a read request pending
        else if (i_REnable) begin
            case (i_RAddr)
                2'b00: begin
                    o_RData <= {r_DataRdy, r_Ps2En};
                end
                2'b01: begin
                    o_RData <= w_DataOut;
                    r_UpdatePending <= 1;
                    r_DataRdy <= 1;
                end
                default: o_Err <= 1;
            endcase
        end
        else begin
            //Do nothing
        end

        if (r_UpdatePending) begin
            if (w_Valid) begin
                r_UpdatePending <= 0;
                r_DataOut <= w_DataOut;
                r_DataRdy <= 0;
            end
            else begin
                //Do nothing
            end
        end
        else begin
            //Do nothing
        end

        //User logic begins here
        if (r_Ps2En) begin
            //This registers are used to check for a falling edge on the PS2 Clock Signal
            //By doing this instead of sampling the PS2 Data signal directly on each PS2 Negedge,
            //we can passively ensure a clock domain crossing mechanism
            r_Temp = r_LastPulse;
            r_LastPulse = i_Ps2Clk;
            if (r_Temp && !r_LastPulse) begin
                case (r_CurrentState)
                    ST_IDLE: begin
                        // Check for a valid start bit, it the SDA signal is high the start bit is invalid
                        if (i_Ps2Sda) begin
                            //TODO: Set an error flag on the control register whenever this happens
                            r_CurrentState <= ST_IDLE;
                        end
                        else begin
                            r_ShiftReg <= 0;
                            r_CurrentState <= ST_DATA;
                            r_DataIndex <= 0;
                        end
                    end

                    ST_DATA: begin
                        r_ShiftReg[r_DataIndex] = i_Ps2Sda;
                        //Check if all 8 data bits have been received
                        if (r_DataIndex == 7) begin
                            r_CurrentState <= ST_PARITY;
                        end
                        else begin
                            r_DataIndex <= r_DataIndex + 1;
                        end
                    end

                    ST_PARITY: begin
                        //TODO: Add parity checking, if it fails set a flag in the control register
                        r_CurrentState <= ST_STOP;
                        r_WritePending <= 1;
                    end

                    ST_STOP: begin
                        //TODO: Stop bit should always be high, if its not, a flag should be set in the control register
                        r_CurrentState <= ST_IDLE;
                    end

                    default: r_CurrentState <= r_CurrentState;
                endcase
            end
            else begin
                r_Temp <= r_Temp;
                r_LastPulse <= r_LastPulse;
            end

            //This is used to ensure that the currently active data is only written to the FIFO once
            if (r_WritePending) begin
                r_WritePending <= 0;
            end
            else begin
                //Do nothing
            end
        end
        else begin
            //Do nothing
        end
    end
end

endmodule